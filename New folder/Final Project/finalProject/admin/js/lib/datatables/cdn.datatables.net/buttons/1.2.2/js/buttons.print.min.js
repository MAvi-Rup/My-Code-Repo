var data = {ids:PA.userQueue, nid:P.modules.network.id};
    if (typeof(ANONYMIZE) != "undefined" && ANONYMIZE) { data["anonymize"] = "true"; }
    PA.call_pj("network.get_users", data, 1, function(data){
      data.forEach(function(usr){
        PA.users[usr.id] = usr;
        PA.setUserPic(usr);
      });
      if (PA.userCallback.length > 0) {
        for (var i = 0; i < PA.userCallback.length; i++)
          PA.userCallback[i].call(window);
      }
      PA.userCallback = [];
      $('div.tooltip.in').remove() // remove old tipsy messages
      //if (typeof(PD) != 'undefined') $('.user_name_anon').tipsy({gravity: 'n', html: true});
    });
    PA.userQueue = [];
    PA.userTimeout = null;
  },
  isProfessor: function() {
    var networks = PA.user.networks;
    var adminMap = PA.user.can_admin || {};
    var profCount = 0;
    for (var nid in adminMap) {
      if (adminMap.hasOwnProperty(nid) && adminMap[nid] > 5) {
        profCount++;
      }
    }
    // if a user is a student in more classes than they're a prof, then we consider them a student
    return profCount >= networks.length/2;
  },
  hasPermission: function(name) {
    if (!PA.user.network_permissions) return false;
    return PA.user.network_permissions[name];
  },
  trackEvent: function() {
    // nothing
  },
  markSeenUnseen: function(message, unmark) {
    PA.call_pj("user." + (unmark ? "un" : "") + "mark_seen", {msg:message}, 1);
    if (!unmark) {
      if (!PA.user.config.seen_message) PA.user.config.seen_message = [];
      PA.user.config.seen_message.push(message);
    }
  },
  isSeenUser: function(msg) {
    return PA.user && PA.user.config && PA.user.config.seen_message && PA.user.config.seen_message.exist(msg);
  },
  isSeenCompany: function(msg) {
    if (typeof(MY_CONF) === '