 the terminal window of {buf}.
		{buf} is used as with |term_getsize()|.

		The first line has {row} one.  When {row} is "." the cursor
		line is used.  When {row} is invalid an empty string is
		returned.

		To get attributes of each character use |term_scrape()|.

		Can also be used as a |method|: >
			GetBufnr()->term_getline(row)


term_getscrolled({buf})					*term_getscrolled()*
		Return the number of lines that scrolled to above the top of
		terminal {buf}.  This is the offset between the row number
		used for |term_getline()| and |getline()|, so that: >
			term_getline(buf, N)
<		is equal to: >
			getline(N + term_getscrolled(buf))
<		(if that line exists).

		{buf} is used as with |term_getsize()|.

		Can also be used as a |method|: >
			GetBufnr()->term_getscrolled()


term_getsize({buf})					*term_getsize()*
		Get the size of terminal {buf}. Returns a list with two
		numbers: [rows, cols].  This is the size of the terminal, not
		the window containing the terminal.

		{buf} must be the buffer number of a terminal window.  Use an
		empty string for the current buffer.  If the buffer does not
		exist or is not a terminal window, an empty list is returned.

		Can also be used as a |method|: >
			GetBufnr()->term_getsize()


term_getstatus({buf})					*term_getstatus()*
		Get the status of terminal {buf}. This returns a String with
		a comma separated list of these items:
			running		job is running
			finished	job has finished
			normal		in Terminal-Normal mode
		One of "running" or "finished" is always present.

		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		string is returned.

		Can also be used as a |method|: >
			GetBufnr()->term_getstatus()


term_gettitle({buf})					*term_gettitle()*
		Get the title of terminal {buf}. This is the title that the
		job in the terminal has set.

		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		string is returned.

		Can also be used as a |method|: >
			GetBufnr()->term_gettitle()


term_gettty({buf} [, {input}])				*term_gettty()*
		Get the name of the controlling terminal associated with
		terminal window {buf}.  {buf} is used as with |term_getsize()|.

		When {input} is omitted or 0, return the name for writing
		(stdout). When {input} is 1 return the name for reading
		(stdin). On UNIX, both return same name.

		Can also be used as a |method|: >
			GetBufnr()->term_gettty()


term_list()						*term_list()*
		Return a list with the buffer numbers of all buffers for
		terminal windows.


term_scrape({buf}, {row})				*term_scrape()*
		Get the contents of {row} of terminal screen of {buf}.
		For {buf} see |term_getsize()|.

		The first line has {row} one.  When {row} is "." the cursor
		line is used.  When {row} is invalid an empty string is
		returned.

		Return a List containing a Dict for each screen cell:
		    "chars"	character(s) at the cell
		    "fg"	foreground color as #rrggbb
		    "bg"	background color as #rrggbb
		    "attr"	attributes of the cell, use |term_getattr()|
				to get the individual flags
		    "width"	cell width: 1 or 2

		Can also be used as a |method|: >
			GetBufnr()->term_scrape(row)


term_sendkeys({buf}, {keys})				*term_sendkeys()*
		Send keystrokes {keys} to terminal {buf}.
		{buf} is used as with |term_getsize()|.

		{keys} are translated as key sequences. For example, "\<c-x>"
		means the character CTRL-X.

		Can also be used as a |method|: >
			GetBufnr()->term_sendkeys(keys)


term_setapi({buf}, {expr})				*term_setapi()*
		Set the function name prefix to be used for the |terminal-api|
		function in terminal {buf}.  For example: >
		    :call term_setapi(buf, "Myapi_")
		    :call term_setapi(buf, "")
<
		The default is "Tapi_".  When {expr} is an empty string then
		no |terminal-api| function can be used for {buf}.

term_setansicolors({buf}, {colors})			*term_setansicolors()*
		Set the ANSI color palette used by terminal {buf}.
		{colors} must be a List of 16 valid color names or hexadecimal
		color codes, like those accepted by |highlight-guifg|.
		Also see |term_getansicolors()| and |g:terminal_ansi_colors|.

		The colors normally are:
			0    black
			1    dark red
			2    dark green
			3    brown
			4    dark blue
			5    dark magenta
			6    dark cyan
			7    light grey
			8    dark grey
			9    red
			10   green
			11   yellow
			12   blue
			13   magenta
			14   cyan
			15   white

		These colors are used in the GUI and in the terminal when
		'termguicolors' is set.  When not using GUI colors (GUI mode
		or 'termguicolors'), the terminal window always uses the 16
		ANSI colors of the underlying terminal.

		Can also be used as a |method|: >
			GetBufnr()->term_setansicolors(colors)

<		{only available with GUI enabled and/or the |+termguicolors|
		feature}

term_setkill({buf}, {how})				*term_setkill()*
		When exiting Vim or trying to close the terminal window in
		another way, {how} defines whether the job in the terminal can
		be stopped.
		When {how} is empty (the default), the job will not be
		stopped, trying to exit will result in |E947|.
		Otherwise, {how} specifies what signal to send to the job.
		See |job_stop()| for the values.

		After sending the signal Vim will wait for up to a second to
		check that the job actually stopped.

		Can also be used as a |method|: >
			GetBufnr()->term_setkill(how)


term_setrestore({buf}, {command})			*term_setrestore()*
		Set the command to write in a session file to restore the job
		in this terminal.  The line written in the session file is: >
			terminal ++curwin ++cols=%d ++rows=%d {command}
<		Make sure to escape the command properly.

		Use an empty {command} to run 'shell'.
		Use "NONE" to not restore this window.

		Can also be used as a |method|: >
			GetBufnr()->term_setrestore(command)


term_setsize({buf}, {rows}, {cols})		*term_setsize()* *E955*
		Set the size of terminal {buf}. The size of the window
		containing the terminal will also be adjusted, if possible.
		If {rows} or {cols} is zero or negative, that dimension is not
		changed.

		{buf} must be the buffer number of a terminal window.  Use an
		empty string for the current buffer.  If the buffer does not
		exist or is not a terminal window, an error is given.

		Can also be used as a |method|: >
			GetBufnr()->term_setsize(rows, cols)


term_start({cmd} [, {options}])			*term_start()*
		Open a terminal window and run {cmd} in it.

		{cmd} can be a string or a List, like with |job_start()|. The
		string "NONE" can be used to open a terminal window without
		starting a job, the pty of the terminal can be used by a
		command like gdb.

		Returns the buffer number of the terminal window.  If {cmd}
		cannot be executed the window does open and shows an error
		message.
		If opening the window fails zero is returned.

		{options} are similar to what is used for |job_start()|, see
		|job-options|.  However, not all options can be used.  These
		are supported:
		   all timeout options
		   "stoponexit", "cwd", "env"
		   "callback", "out_cb", "err_cb", "exit_cb", "close_cb"
		   "in_io", "in_top", "in_bot", "in_name", "in_buf"
		   "out_io", "out_name", "out_buf", "out_modifiable", "out_msg"
		   "err_io", "err_name", "err_buf", "err_modifiable", "err_msg"
		However, at least one of stdin, stdout or stderr must be
		connected to the terminal.  When I/O is connected to the
		terminal then the callback function for that part is not used.

		There are extra options:
		   "term_name"	     name to use for the buffer name, instead
				     of the command name.
		   "term_rows"	     vertical size to use for the terminal,
				     instead of using 'termwinsize'
		   "term_cols"	     horizontal size to use for the terminal,
				     instead of using 'termwinsize'
		   "vertical"	     split the window vertically; note that
				     other window position can be defined with
				     command modifiers, such as |:belowright|.
		   "curwin"	     use the current window, do not split the
				     window; fails if the current buffer
				     cannot be |abandon|ed
		   "hidden"	     do not open a window
		   "norestore"	     do not add the terminal window to a
				     session file
		   "term_kill"	     what to do when trying to close the
				     terminal window, see |term_setkill()|
		   "term_finish"     What to do when the job is finished:
					"close": close any windows
					"open": open window if needed
				     Note that "open" can be interruptive.
				     See |term++close| and |term++open|.
		   "term_opencmd"    command to use for opening the window when
				     "open" is used for "term_finish"; must
				     have "%d" where the buffer number goes,
				     e.g. "10split|buffer %d"; when not
				     specified "botright sbuf %d" is used
		   "term_highlight"  highlight group to use instead of
				     "Terminal"
		   "eof_chars"	     Text to send after all buffer lines were
				     written to the terminal.  When not set
				     CTRL-D is used on MS-Windows. For Python
				     use CTRL-Z or "exit()". For a shell use
				     "exit".  A CR is always added.
		   "ansi_colors"     A list of 16 color names or hex codes
				     defining the ANSI palette used in GUI
				     color modes.  See |g:terminal_ansi_colors|.
		   "tty_type"	     (MS-Windows only): Specify which pty to
				     use.  See 'termwintype' for the values.
		   "term_api"	     function name prefix for the
				     |terminal-api| function.  See
				     |term_setapi()|.

		Can also be used as a |method|: >
			GetCommand()->term_start()


term_wait({buf} [, {time}])					*term_wait()*
		Wait for pending updates of {buf} to be handled.
		{buf} is used as with |term_getsize()|.
		{time} is how long to wait for updates to arrive in msec.  If
		not set then 10 msec will be used.

		Can also be used as a |method|: >
			GetBufnr()->term_wait()

==============================================================================
3. Terminal communication			 *terminal-communication*

There are several ways to communicate with the job running in a terminal:
- Use |term_sendkeys()| to send text and escape sequences from Vim to the job.
- Use the JSON API to send encoded commands from the job to Vim.
- Use the |client-server| mechanism. This works on machines with an X server
  and on MS-Windows.


Vim to job: term_sendkeys() ~
							*terminal-to-job*
This allows for remote controlling the job running in the terminal.  It is a
one-way mechanism.  The job can update the display to signal back to Vim.
For example, if a shell is running in a terminal, you can do: >
	call term_sendkeys(buf, "ls *.java\<CR>")

This requires for the job to be in the right state where it will do the right
thing when receiving the keys.  For the above example, the shell must be
waiting for a command to be typed.

For a job that was written for the purpose, you can use the JSON API escape
sequence in the other direction.  E.g.: >
	call term_sendkeys(buf, "\<Esc>]51;["response"]\x07")


Job to Vim: JSON API ~
							*terminal-api*
The job can send JSON to Vim, using a special escape sequence.  The JSON
encodes a command that Vim understands.  Example of such a message: >
	<Esc>]51;["drop", "README.md"]<07>

The body is always a list, making it easy to find the end: ]<07>.
The <Esc>]51;msg<07> sequence is reserved by xterm for "Emacs shell", which is
similar to what we are doing here.

Currently supported commands:

	call {funcname} {argument}

		Call a user defined function with {argument}.
		The function is called with two arguments: the buffer number
		of the terminal and {argument}, the decoded JSON argument.
		By default, the function name must start with "Tapi_" to avoid
		accidentally calling a function not meant to be used for the
		terminal API.  This can be changed with |term_setapi()|.
		The user function should sanity check the argument.
		The function can use |term_sendkeys()| to send back a reply.
		Example in JSON: >
			["call", "Tapi_Impression", ["play", 14]]
<		Calls a function defined like this: >
			function Tapi_Impression(bufnum, arglist)
			  if len(a:arglist) == 2
			    echomsg "impression " . a:arglist[0]
			    echomsg "count " . a:arglist[1]
			  endif
			endfunc
<		Output from `:echo` may be erased by a redraw, use `:echomsg`
		to be able to see it with `:messages`.

	drop {filename} [options]

		Let Vim open a file, like the `:drop` command.  If {filename}
		is already open in a window, switch to that window.  Otherwise
		open a new window to edit {filename}.
		Note that both the job and Vim may change the current
		directory, thus it's best to use the full path.

		[options] is only used when opening a new window.  If present,
		it must be a Dict.  Similarly to |++opt|, these entries are
		recognized:
		  "ff"		file format: "dos", "mac" or "unix"
		  "fileformat"	idem
		  "enc"		overrides 'fileencoding'
		  "encoding"	idem
		  "bin"		sets 'binary'
		  "binary"	idem
		  "nobin"	resets 'binary'
		  "nobinary"	idem
		  "bad"		specifies behavior for bad characters, see
				|++bad|

		Example in JSON: >
			["drop", "path/file.txt", {"ff": "dos"}]

A trick to have Vim send this escape sequence: >
	exe "set t_ts=\<Esc>]51; t_fs=\x07"
	let &titlestring = '["call","Tapi_TryThis",["hello",123]]'
	redraw
	set t_ts& t_fs&

Rationale: Why not allow for any command or expression?  Because that might
create a security problem.


Using the client-server feature ~
						*terminal-client-server*
This only works when v:servername is not empty.  If needed you can set it,
before opening the terminal, with: >
	call remote_startserver('vim-server')

$VIM_SERVERNAME is set in the terminal to pass on the server name.

In the job you can then do something like: >
	vim --servername $VIM_SERVERNAME --remote +123 some_file.c
This will open the file "some_file.c" and put the cursor on line 123.

==============================================================================
4. Remote testing					*terminal-testing*

Most Vim tests execute a script inside Vim.  For some tests this does not
work, running the test interferes with the code being tested.  To avoid this
Vim is executed in a terminal window.  The test sends keystrokes to it and
inspects the resulting screen state.

Functions ~

|term_sendkeys()|	send keystrokes to a terminal (not subject to tmap)
|term_wait()|		wait for screen to be updated
|term_scrape()|		inspect terminal screen


==============================================================================
5. Diffing screen dumps					*terminal-diff*

In some cases it can be bothersome to test that Vim displays the right
characters on the screen.  E.g. with syntax highlighting.  To make this
simpler it is possible to take a screen dump of a terminal and compare it to
an expected screen dump.

Vim uses the window size, text, color and other attributes as displayed.  The
Vim screen size, font and other properties do not matter.  Therefore this
mechanism is portable across systems.  A conventional screenshot would reflect
all differences, including font size and family.


Writing a screen dump test for Vim ~
							*terminal-dumptest*
For an example see the Test_syntax_c() function in
src/testdir/test_syntax.vim.  The main parts are:
- Write a file you want to test with. This is useful for testing syntax
  highlighting.  You can also start Vim with an empty buffer.
- Run Vim in a terminal with a specific size.  The default is 20 lines of 75
  characters.  This makes sure the dump is always this size.  The function
  RunVimInTerminal() takes care of this.  Pass it the arguments for the Vim
  command.
- Send any commands to Vim using |term_sendkeys()|.  For example: >
	call term_sendkeys(buf, ":echo &lines &columns\<CR>")
- Check that the screen is now in the expected state, using
  VerifyScreenDump().  This expects the reference screen dump to be in the
  src/testdir/dumps/ directory.  Pass the name without ".dump".  It is
  recommended to use the name of the test function and a sequence number, so
  that we know what test is using the file.
- Repeat sending commands and checking the state.
- Finally stop Vim by calling StopVimInTerminal().

The first time you do this you won't have a screen dump yet.  Create an empty
file for now, e.g.: >
	touch src/testdir/dumps/Test_function_name_01.dump

The test will then fail, giving you the command to compare the reference dump
and the failed dump, e.g.: >
	call term_dumpdiff("failed/Test_func.dump", "dumps/Test_func.dump")

Use this command in Vim, with the current directory set to src/testdir.
Once you are satisfied with the test, move the failed dump in place of the
reference: >
	:!mv failed/Test_func.dump dumps/Test_func.dump


Creating a screen dump ~
							*terminal-screendump*

To create the screen dump, run Vim (or any other program) in a terminal and
make it show the desired state.  Then use the |term_dumpwrite()| function to
create a screen dump file.  For example: >
	:call term_dumpwrite(77, "mysyntax.dump")

Here "77" is the buffer number of the terminal.  Use `:ls!` to see it.

You can view the screen dump with |term_dumpload()|: >
	:call term_dumpload("mysyntax.dump")

To verify that Vim still shows exactly the same screen, run Vim again with
exactly the same way to show the desired state.  Then create a screen dump
again, using a different file name: >
	:call term_dumpwrite(88, "test.dump")

To assert that the files are exactly the same use |assert_equalfile()|: >
	call assert_equalfile("mysyntax.dump", "test.dump")

If there are differences then v:errors will contain the error message.


Comparing screen dumps ~
						*terminal-diffscreendump*

|assert_equalfile()| does not make it easy to see what is different.
To spot the problem use |term_dumpdiff()|: >
	call term_dumpdiff("mysyntax.dump", "test.dump")

This will open a window consisting of three parts:
1.  The contents of the first dump
2.  The difference between the first and second dump
3.  The contents of the second dump

You can usually see what differs in the second part.  Use the 'ruler' to
relate it to the position in the first or second dump.  Letters indicate the
kind of difference:
	X	different character
	>	cursor in first but not in second
	<	cursor in second but not in first
	w	character width differs (single vs double width)
	f	foreground color differs
	b	background color differs
	a	attribute differs (bold, underline, reverse, etc.)
	?	character missing in both
	+	character missing in first
	-	character missing in second

Alternatively, press "s" to swap the first and second dump. Do this several
times so that you can spot the difference in the context of the text.

==============================================================================
6. Debugging				*terminal-debug* *terminal-debugger*

The Terminal debugging plugin can be used to debug a program with gdb and view
the source code in a Vim window.  Since this is completely contained inside
Vim this also works remotely over an ssh connection.

When the |+terminal| feature is missing, the plugin will use the "prompt"
buffer type, if possible.  The running program will then use a newly opened
terminal window.  See |termdebug-prompt| below for details.


Starting ~
							*termdebug-starting*
Load the plugin with this command: >
	packadd termdebug
<							*:Termdebug*
To start debugging use `:Termdebug` or `:TermdebugCommand` followed by the
command name, for example: >
	:Termdebug vim

This opens two windows:

gdb window	A terminal window in which "gdb vim" is executed.  Here you
		can directly interact with gdb.  The buffer name is "!gdb".

program window	A terminal window for the executed program.  When "run" is
		used in gdb the program I/O will happen in this window, so
		that it does not interfere with controlling gdb.  The buffer
		name is "gdb program".

The current window is used to show the source code.  When gdb pauses the
source file location will be displayed, if possible.  A sign is used to
highlight the current position, using highlight group debugPC.

If the buffer in the current window is modified, another window will be opened
to display the current gdb position.  You can use `:Winbar` to add a window
toolbar there.

Focus the terminal of the executed program to interact with it.  This works
the same as any command running in a terminal window.

When the debugger ends, typically by typing "quit" in the gdb window, the two
opened windows are closed.

Only one debugger can be active at a time.
							*:TermdebugCommand*
If you want to give specific commands to the command being debugged, you can
use the `:TermdebugCommand` command followed by the command name and
additional parameters. >
	:TermdebugCommand vim --clean -c ':set nu'

Both the `:Termdebug` and `:TermdebugCommand` support an optional "!" bang
argument to start the command right away, without pausing at the gdb window
(and cursor will be in the debugged window).  For example: >
	:TermdebugCommand! vim --clean

To attach gdb to an already running executable or use a core file, pass extra
arguments.  E.g.: >
	:Termdebug vim core
	:Termdebug vim 98343

If no argument is given, you'll end up in a gdb window, in which you need to
specify which command to run using e.g. the gdb `file` command.


Example session ~
							*termdebug-example*
Start in the Vim "src" directory and build Vim: >
	% make
Make sure that debug symbols are present, usually that means that $CFLAGS
includes "-g".

Start Vim: >
	% ./vim

Load the termdebug plugin and start debugging Vim: >
	:packadd termdebug
	:Termdebug vim
You should now have three windows:
    source  - where you started, has a window toolbar with buttons
    gdb	    - you can type gdb commands here
    program - the executed program will use this window

You can use CTRL-W CTRL-W or the mouse to move focus between windows.
Put focus on the gdb window and type: >
	break ex_help
	run
Vim will start running in the program window. Put focus there and type: >
	:help gui
Gdb will run into the ex_help breakpoint.  The source window now shows the
ex_cmds.c file.  A red "1 " marker will appear in the signcolumn where the
breakpoint was set.  The line where the debugger stopped is highlighted.  You
can now step through the program.  Let's use the mouse: click on the "Next"
button in the window toolbar.  You will see the highlighting move as the
debugger executes a line of source code.

Click "Next" a few times until the for loop is highlighted.  Put the cursor on
the end of "eap->arg", then click "Eval" in the toolbar.  You will see this
displayed:
	"eap->arg": 0x555555e68855 "gui" ~
This way you can inspect the value of local variables.  You can also focus the
gdb window and use a "print" command, e.g.: >
	print *eap
If mouse pointer movements are working, Vim will also show a balloon when the
mouse rests on text that can be evaluated by gdb.

Now go back to the source window and put the cursor on the first line after
the for loop, then type: >
	:Break
You will see a ">>" marker appear, this indicates the new breakpoint.  Now
click "Cont" in the toolbar and the code until the breakpoint will be
executed.

You can type more advanced commands in the gdb window.  For example, type: >
	watch curbuf
Now click "Cont" in the toolbar (or type "cont" in the gdb window). Execution
will now continue until the value of "curbuf" changes, which is in do_ecmd().
To remove this watchpoint again type in the gdb window: >
	delete 3

You can see the stack by typing in the gdb window: >
	where
Move through the stack frames, e.g. with: >
	frame 3
The source window will show the code, at the point where the call was made to
a deeper level.


Stepping through code ~
							*termdebug-stepping*
Put focus on the gdb window to type commands there.  Some common ones are:
- CTRL-C	interrupt the program
- next		execute the current line and stop at the next line
- step		execute the current line and stop at the next statement,
		entering functions
- finish	execute until leaving the current function
- where		show the stack
- frame N	go to the Nth stack frame
- continue	continue execution

						*:Run* *:Arguments*
In the window showing the source code these commands can be used to control
gdb:
 `:Run` [args]	    run the program with [args] or the previous arguments
 `:Arguments` {args}  set arguments for the next `:Run`

 *:Break*	set a breakpoint at the cursor position
 :Break {position}
		set a breakpoint at the specified position
 *:Clear*	delete the breakpoint at the cursor position

 *:Step*	execute the gdb "step" command
 *:Over*	execute the gdb "next" command (`:Next` is a Vim command)
 *:Finish*	execute the gdb "finish" command
 *:Continue*	execute the gdb "continue" command
 *:Stop*	interrupt the program

If 'mouse' is set the plugin adds a window toolbar with these entries:
  Step		`:Step`
  Next		`:Over`
  Finish	`:Finish`
  Cont		`:Continue`
  Stop		`:Stop`
  Eval		`:Evaluate`
This way you can use the mouse to perform the most common commands.  You need
to have the 'mouse' option set to enable mouse clicks.
								*:Winbar*
You can add the window toolbar in other windows you open with: >
  :Winbar

If gdb stops at a source line and there is no window currently showing the
source code, a new window will be created for the source code.  This also
happens if the buffer in the source code window has been modified and can't be
abandoned.

Gdb gives each breakpoint a number.  In Vim the number shows up in the sign
column, with a red background.  You can use these gdb commands:
- info break	list breakpoints
- delete N	delete breakpoint N
You can also use the `:Clear` command if the cursor is in the line with the
breakpoint, or use the "Clear breakpoint" right-click menu entry.


Inspecting variables ~
					*termdebug-variables* *:Evaluate*
 `:Evaluate`	    evaluate the expression under the cursor
 `K`		    same (see |termdebug_map_K| to disable)
 `:Evaluate` {expr}   evaluate {expr}
 `:'<,'>Evaluate`     evaluate the Visually selected text

This is similar to using "print" in the gdb window.
You can usually shorten `:Evaluate` to `:Ev`.


Other commands ~
							*termdebug-commands*
 *:Gdb*	     jump to the gdb window
 *:Program*    jump to the window with the running program
 *:Source*     jump to the window with the source code, create it if there
	     isn't one


Prompt mode ~
						*termdebug-prompt*
When the |+terminal| feature is not supported and on MS-Windows, gdb will run
in a buffer with 'buftype' set to "prompt".  This works slightly differently:
- The gdb window will be in Insert mode while typing commands.  Go to Normal
  mode with <Esc>, then you can move around in the buffer, copy/paste, etc.
  Go back to editing the gdb command with any command that starts Insert mode,
  such as `a` or `i`.
- The program being debugged will run in a separate window.  On MS-Windows
  this is a new console window.  On Unix, if the |+terminal| feature is
  available a Terminal window will be opened to run the debugged program in.

						*termdebug_use_prompt*
Prompt mode can be used even when the |+terminal| feature is present with: >
	let g:termdebug_use_prompt = 1
<
						*termdebug_map_K*
The K key is normally mapped to :Evaluate. If you do not want this use: >
	let g:termdebug_map_K = 0


Communication ~
						*termdebug-communication*
There is another, hidden, buffer, which is used for Vim to communicate with
gdb.  The buffer name is "gdb communication".  Do not delete this buffer, it
will break the debugger.

Gdb has some weird behavior, the plugin does its best to work around that.
For example, after typing "continue" in the gdb window a CTRL-C can be used to
interrupt the running program.  But after using the MI command
"-exec-continue"  pressing CTRL-C does not interrupt.  Therefore you will see
"continue" being used for the `:Continue` command, instead of using the
communication channel.


Customizing ~

GDB command						 *termdebug-customizing*

To change the name of the gdb command, set the "termdebugger" variable before
invoking `:Termdebug`: >
	let termdebugger = "mygdb"
<							*gdb-version*
Only debuggers fully compatible with gdb will work.  Vim uses the GDB/MI
interface.  The "new-ui" command  requires gdb version 7.12 or later.  if you
get this error:
	Undefined command: "new-ui". Try "help".~
Then your gdb is too old.


Colors						*hl-debugPC* *hl-debugBreakpoint*

The color of the signs can be adjusted with these highlight groups:
- debugPC		the current position
- debugBreakpoint	a breakpoint

The defaults are, when 'background' is "light":
  hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red

When 'background' is "dark":
  hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red


Shortcuts						*termdebug_shortcuts*

You can define your own shortcuts (mappings) to control gdb, that can work in
any window, using the TermDebugSendCommand() function.  Example: >
	map ,w :call TermDebugSendCommand('where')<CR>
The argument is the gdb command.


Popup menu						*termdebug_popup*

By default the Termdebug plugin sets 'mousemodel' to "popup_setpos" and adds
these entries to the popup menu:
	Set breakpoint		`:Break`
	Clear breakpoint	`:Clear`
	Evaluate		`:Evaluate`
If you don't want this then disable it with: >
	let g:termdebug_popup = 0


Vim window width						*termdebug_wide*

To change the width of the Vim window when debugging starts, and use a
vertical split: >
  let g:termdebug_wide = 163
This will set &columns to 163 when `:Termdebug` is used.  The value is restored
when quitting the debugger.
If g:termdebug_wide is set and &columns is already larger than
g:termdebug_wide then a vertical split will be used without changing &columns.
Set it to 1 to get a vertical split without every changing &columns (useful
for when the terminal can't be resized by Vim).



 vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           58-28-26-72-22-74-22l-43 0 113-106z m-123 278l192 0 0-16-192 0z m0-48l192 0 0-16-192 0z"/>
<glyph unicode="&#47;" d="M512 32l-512 0 0 448 512 0z m-496 16l480 0 0 416-480 0z m448 32l-384 0 0 352 384 0z m-368 16l352 0 0 320-352 0z m-48 288l48 0 0-16-48 0z m0-80l48 0 0-16-48 0z m0-80l48 0 0-16-48 0z m0-80l48 0 0-16-48 0z m304 80c-18 0-32 14-32 32 0 18 14 32 32 32 18 0 32-14 32-32 0-18-14-32-32-32z m0 48c-9 0-16-7-16-16 0-9 7-16 16-16 9 0 16 7 16 16 0 9-7 16-16 16z m0-96c-44 0-80 36-80 80 0 44 36 80 80 80 44 0 80-36 80-80 0-44-36-80-80-80z m0 144c-35 0-64-29-64-64 0-35 29-64 64-64 35 0 64 29 64 64 0 35-29 64-64 64z m-72-56l48 0 0-16-48 0z m64 64l16 0 0-48-16 0z m32-64l48 0 0-16-48 0z m-32-32l16 0 0-48-16 0z m30 14l32-32-12-12-32 32z m20 64l12-12-32-32-12 12z m-84 0l32-32-12-12-32 32z m20-64l12-12-32-32-11 12z"/>
<glyph unicode="&#58;" d="M312-3l-312 312 0 203 203 0 312-312z m-296 318l296-296 181 181-296 296-181 0z m120 5c-31 0-56 25-56 56 0 31 25 56 56 56 31 0 56-25 56-56 0-31-25-56-56-56z m0 96c-22 0-40-18-40-40 0-22 18-40 40-40 22 0 40 18 40 40 0 22-18 40-40 40z"/>
<glyph unicode="&#59;" d="M273 29l-273 272 0 179 179 0 272-273z m-257 279l257-257 156 156-257 257-156 0z m326-274l-11 12 162 161-259 259 11 12 270-271z m-230 286c-26 0-48 22-48 48 0 26 22 48 48 48 26 0 48-22 48-48 0-26-22-48-48-48z m0 80c-18 0-32-14-32-32 0-18 14-32 32-32 18 0 32 14 32 32 0 18-14 32-32 32z"/>
<glyph unicode="&#60;" d="M192-3l-59 59 5 6c11 10 14 18 14 34 0 32-24 56-56 56-16 0-24-3-34-14l-6-5-59 59 323 323 59-59-5-6c-11-10-14-18-14-34 0-32 24-56 56-56 16 0 24 3 34 14l6 5 59-59z m-37 59l37-37 301 301-37 37c-12-10-23-13-40-13-41 0-72 31-72 72 0 17 3 28 13 40l-37 37-301-301 37-37c12 10 23 13 40 13 41 0 72-31 72-72 0-17-3-28-13-40z m59 342l32-32-12-12-32 32z m152-152l32-32-12-12-32 32z m-104 104l32-32-12-12-32 32z m56-56l32-32-12-12-32 32z"/>
<glyph unicode="&#61;" d="M256 0c-68 0-133 27-181 75-48 48-75 113-75 181 0 68 27 133 75 181 48 48 113 75 181 75 68 0 133-27 181-75 48-48 75-113 75-181 0-68-27-133-75-181-48-48-113-75-181-75z m0 496c-64 0-124-25-170-70-45-46-70-106-70-170 0-64 25-124 70-170 46-45 106-70 170-70 64 0 124 25 170 70 45 46 70 106 70 170 0 64-25 124-70 170-46 45-106 70-170 70z m-8-120l16 0 0-280-16 0z m-104 8l224 0 0-16-224 0z m164-57l8-14-112-64-8 14z m0-48l8-14-112-64-8 14z"/>
<glyph unicode="&#62;" d="M496 64l-496 0 0 336 496 0 0-96-16 0 0 80-464 0 0-304 464 0 0 80 16 0z m-56 328l-16 0 0 40-376 0 0 16 392 0z m-424 8l-16 0c0 26 22 48 48 48l0-16c-18 0-32-14-32-32z m496-248l-167 0c-44 0-80 36-80 80 0 44 36 80 80 80l167 0z m-167 144c-35 0-64-29-64-64 0-35 29-64 64-64l151 0 0 128z m7-96c-18 0-32 14-32 32 0 18 14 32 32 32 18 0 32-14 32-32 0-18-14-32-32-32z m0 48c-9 0-16-7-16-16 0-9 7-16 16-16 9 0 16 7 16 16 0 9-7 16-16 16z"/>
<glyph unicode="&#63;" d="M256 0c-68 0-133 27-181 75-48 48-75 113-75 181 0 68 27 133 75 181 48 48 113 75 181 75 68 0 133-27 181-75 48-48 75-113 75-181 0-68-27-133-75-181-48-48-113-75-181-75z m0 496c-64 0-124-25-170-70-45-46-70-106-70-170 0-64 25-124 70-170 46-45 106-70 170-70 64 0 124 25 170 70 45 46 70 106 70 170 0 64-25 124-70 170-46 45-106 70-170 70z m78-376l-20 0-56 240-4 0-56-240-20 0-66 262 16 4 60-240 54 230 28 0 54-230 60 240 16-4z m-230 160l304 0 0-16-304 0z m0-48l304 0 0-16-304 0z"/>
<glyph unicode="&#64;" d="M256 0c-68 0-133 27-181 75-48 48-75 113-75 181 0 68 27 133 75 181 48 48 113 75 181 75 68 0 133-27 181-75 48-48 75-113 75-181 0-68-27-133-75-181-48-48-113-75-181-75z m0 496c-64 0-124-25-170-70-45-46-70-106-70-170 0-64 25-124 70-170 46-45 106-70 170-70 64 0 124 25 170 70 45 46 70 106 70 170 0 64-25 124-70 170-46 45-106 70-170 70z m8-368l-16 0 0 117-95 134 14 10 97-138z m81 261l14-10-96-136-14 10z m-177-157l176 0 0-16-176 0z m104 48l72 0 0-16-72 0z m-104 0l72 0 0-16-72 0z"/>
<glyph unicode="&#91;" d="M256 0c-68 0-133 27-181 75-48 48-75 113-75 181 0 68 27 133 75 181 48 48 113 75 181 75 68 0 133-27 181-75 48-48 75-113 75-181 0-68-27-133-75-181-48-48-113-75-181-75z m0 496c-64 0-124-25-170-70-45-46-70-106-70-170 0-64 25-124 70-170 46-45 106-70 170-70 64 0 124 25 170 70 45 46 70 106 70 170 0 64-25 124-70 170-46 45-106 70-170 70z m-96-112l192 0 0-16-192 0z m-32-48l256 0 0-16-256 0z m56-216l-32 0 0 16 32 0c15 0 16 32 16 32l0 160 16 0 0-160c0-18-7-48-32-48z m160 0l-16 0c-32 0-40 26-40 40l0 168 16 0 0-168c0-4 1-24 24-24l16 0z"/>
</font></defs></svg>
